# 队列

## 单调队列

***“如果一个选手比你小还比你强，你就可以退役了。”**——单调队列的原理*

**单调队列**是一种主要用于解决**滑动窗口**类问题的数据结构，即，在长度为n的序列中，求每个长度为m的区间的区间最值。它的时间复杂度是O(n)，在这个问题中比 O(nlogn) 的[ST表](https://zhuanlan.zhihu.com/p/105439034)和[线段树](https://zhuanlan.zhihu.com/p/106118909)要优。

![img](https://pic4.zhimg.com/80/v2-ef66afc38e068600939980673114127f_720w.jpg)

单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素**可能**成为某个区间最值时才保留它。

形象地打个比方，上面的序列可以看成学校里各个年级XCPC选手，数字越大代表能力越强。每个选手只能在大学四年间参赛，毕业了就没有机会了。那么，每一年的王牌选手都在哪个年级呢？

一开始的时候，大三大四的学长都比较菜，大二的最强，而大一的等大二的毕业后还有机会上位，所以队列里有两个数。

![img](https://pic3.zhimg.com/80/v2-eeda8e22e5931732675ab99754f93bce_720w.jpg)

一年过去了，原本大一的成为大二，却发现新进校的新生非常强，自己再也没有机会成为最大值了，所以弹出队列。

![img](https://pic4.zhimg.com/80/v2-6749c5666b76cdc2f497df072f8626b3_720w.jpg)

又过了一年，新入校的新生尽管能力只有1，但理论上只要后面的人比他还菜，还是可能成为区间最大值的，所以入队。

![img](https://pic4.zhimg.com/80/v2-e8be2abc277505561313d865b856d327_720w.jpg)

终于，原本的王牌毕业了，后面的人以为熬出头了，谁知道这时一个巨佬级别的新生进入了集训队，这下其他所有人都没机会了。

![img](https://pic3.zhimg.com/80/v2-71dc212718a2565ce57d9e334c93da2e_720w.jpg)

*（这只是比方，现实中各位选手的实力是会增长的，不符合这个模型ovo）*

总之，观察就会发现，我们维护的这个队列总是单调递减的。如果维护区间最小值，那么维护的队列就是单调递增的。这就是为什么叫**单调**队列。

代码也很简洁：

```cpp
deque<int> Q; // 存储的是编号
for (int i = 0; i < n; ++i)
{
    if (!Q.empty() && i - Q.front() >= m) // 毕业
        Q.pop_front();
    while (!Q.empty() && V[Q.back()] < V[i]) // 比新生弱的当场退役（求区间最小值把这里改成>即可）
        Q.pop_back();
    Q.push_back(i); // 新生入队
    if (i >= m - 1)
        cout << V[Q.front()] << " ";
}
```

## 优先队列（堆）

**优先队列**是特殊的队列，从“优先”一词，可看出**有“插队现象”**。比如在火车站排队进站时，就会有些比较急的人来插队，他们就在前面先通过验票。优先队列**至少含有两种操作**的数据结构：**insert（插入）**，即将元素插入到优先队列中（入队）；以及**deleteMin（删除最小者）**，它的作用是找出、删除优先队列中的最小的元素（出队）。

![优先队列](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/19/16a35ec42f89c9cd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



- 优先队列的实现常选用**二叉堆**，**在数据结构中，优先队列一般也是指堆**。

- **堆的两个性质：**

  - **结构性****：**堆是一颗除底层外被完全填满的二叉树，底层的节点从左到右填入，这样的树叫做**完全二叉树**。

    ![image-20220827151545340](https://myyoss.oss-cn-shenzhen.aliyuncs.com/img/md/202208271515453.png)

  - **堆序性：**由于我们想很快找出最小元，则最小元应该在根上，**任意节点都小于它的后裔**，这就是**小顶堆（Min-Heap）**；如果是查找最大元，则最大元应该在根上，**任意节点都要大于它的后裔**，这就是**大顶堆(Max-heap)。**

## ref

[算法学习笔记(66): 单调队列](https://zhuanlan.zhihu.com/p/346354943)

[最详细版图解优先队列（堆）](https://juejin.cn/post/6844903826856607757)